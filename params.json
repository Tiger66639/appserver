{"name":"Appserver","tagline":"A multithreaded application server for PHP, written in PHP.","body":"# appserver.io, a PHP application server\r\n\r\n[![Build Status](https://travis-ci.org/Tiger66639/appserver.svg)](https://travis-ci.org/Tiger66639/appserver)\r\n\r\nThis is the main repository for the [appserver.io](http://www.appserver.io/) project.\r\n\r\nappserver.io is a multithreaded application server for PHP, written\r\nin PHP. Yes, pure PHP! If you know anything about PHP, you're probably thinking we might be crazy. Well, we aren't. We are dead serious (but we most certainly still love having fun!).\r\n\r\nappserver.io overcomes some of the biggest overhead issues most PHP (CGI) programs have in common, through a blazingly fast and rock solid infrastructure and with concepts new to PHP. At the same time, appserver.io offers PHP developers the fundamental core features found in most popular frameworks today, yet not intending to be a framework at all. It is a suprizingly fun infrastructure for PHP development, allowing you to build powerful applications without needing the bulk of a PHP framework.\r\n\r\nappserver.io includes great features like...\r\n\r\n - Its own performant Web Server and HTTP foundation.\r\n - A powerful Servlet Engine, with true multi-threading\r\n - A Dependency Injection Container, for building modern, modular and testable code\r\n - Multiple Persistence Containers, for sessions and other stateful components\r\n - A Message Queue System, for contolling the execution of long running tasks\r\n - A Timer Service, for running scheduled tasks\r\n\r\nand much more.\r\n\r\nappserver.io also supports [Aspect Oriented Programming](http://en.wikipedia.org/wiki/Aspect-oriented_programming)(AOP), which is a programming paradigm also found in the most popular frameworks today, like Laravel. AOP allows the separation of cross-cutting concerns within a program, allowing developers to create even more modular systems.\r\n\r\nWith appserver.io, it is our goal to establish a solution as the next standard for enterprise applications written in PHP. With your help, we can reach this goal.\r\n\r\nGive it a try!\r\n\r\n\r\n#### Table of Contents\r\n\r\n* [Semantic Versioning](#semantic-versioning)\r\n* [Installation](#installation)\r\n* [Basic Usage](#basic-usage)\r\n* [HTTP Server](#https-server)\r\n* [Servlet-Engine](#servlet-engine)\r\n* [Annotations](#annotations)\r\n* [Dependency Injection](#dependency-injection)\r\n* [Persistence-Container](#persistence-container)\r\n* [Message-Queue](#message-queue)\r\n* [Timer-Service](#timer-service)\r\n* [AOP](#aop)\r\n* [Design-by-Contract](#design-by-contract)\r\n* [Runtime Environment](#runtime-environment)\r\n* [Configuration](#configuration)\r\n* [Deployment](#deployment)\r\n* [Uninstall](#uninstall)\r\n\r\n# Semantic Versioning\r\n\r\nappserver.io follows semantic versioning. For the purpose of defining a public API we introduced [appserver.io specific `PSRs`](http://appserver.io/get-started/psrs.html). These PSRs are the core to appserver.io's public API, but within their own definition and versioning, meaning that **semantic versioning applies to these PSRs and not the appserver package itself**.\r\n\r\n# Installation\r\n\r\nappserver.io can be installed on several operating systems. It also supports several methods of acquiring the software. To get your appserver.io package you can do one of the following:\r\n\r\n* Download one of our [**releases**](<https://github.com/appserver-io/appserver/releases>)\r\n  right from this repository which provide tested install packages\r\n\r\n* Grab any of our [**nightlies**](<http://builds.appserver.io/>) from our project page to get\r\n  bleeding edge install packages, (and may also containg bugs - only for testing and not for production use!!)\r\n\r\n* Build your own package using [ANT](<http://ant.apache.org/>)! To do so clone the [runtime](<https://github.com/appserver-io-php/runtime>) first. Then update at least the `os.family` and `os.distribution` build properties according to your environment and build the appserver with the ANT `build` and `create-package` target.\r\n\r\nThe package will install with these basic default characteristics:\r\n\r\n* Install dir: `/opt/appserver`\r\n* Autostart after installation, no autostart on reboot\r\n* Reachable under pre-configured ports as described [here](#basic-usage)\r\n\r\nFor OS specific steps and characteristics see below for tested environments.\r\n\r\n## Mac OS X\r\n\r\n> Runs and tested on Mac OS X 10.8.x and higher!\r\n\r\nFor Mac OS X > 10.8.x we provide a `.pkg` file for [download](http://appserver.io/get-started/downloads.html#mac-osx) that contains the runtime and the distribution. Double-clicking on the `.pkg` starts and guides you through the installation process.\r\n\r\n## Windows\r\n\r\n> Runs and tested on Windows 7 (32-bit) and higher!\r\n\r\nAs we deliver the Windows appserver as a .jar file you can [download](http://appserver.io/get-started/downloads.html#windows), a installed Java Runtime Environment (or JDK\r\nthat is) is a vital requirement for using it. If the JRE/JDK is not installed, you have to do so\r\nfirst. You can get the JRE from [Oracle's download page](<http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html>).\r\nIf this requirement is met you can start the installation by simply double-clicking the .jar archive.\r\n\r\n## Debian\r\n\r\n> Runs and tested on Debian Squeeze (64-bit) and higher!\r\n\r\nIf you're on a Debian system you might also try our `.deb` repository:\r\n\r\n```\r\nroot@debian:~# echo \"deb http://deb.appserver.io/ wheezy main\" > /etc/apt/sources.list.d/appserver.list\r\nroot@debian:~# wget http://deb.appserver.io/appserver.gpg -O - | apt-key add -\r\nroot@debian:~# aptitude update\r\nroot@debian:~# aptitude install appserver-dist\r\n```\r\n\r\nOptionally you can [download](http://appserver.io/get-started/downloads.html#debian) the `.deb` files and install them by double-clicking on them. This will invoke the system default package manager and guides you through the installation process. Please install the runtime first, as this is a dependency for the distribution.\r\n\r\n## Fedora\r\n\r\n> Runs and tested on versions Fedora 20 (64-bit) and higher!\r\n\r\nWe  also provide `.rpm` [files](http://appserver.io/get-started/downloads.html#fedora) for Fedora, that you can download and start the installation process by double-clicking on it. This will start the systems default package manager and guides you through the installation process.\r\n\r\n## CentOS\r\n\r\n> Runs and tested on CentOS 6.5 (64-bit) and higher!\r\n\r\nInstallation and basic usage is the same as on Fedora, but we provide different [packages](http://appserver.io/get-started/downloads.html#cent-os). CentOS requires additional repositories\r\nlike [remi](<http://rpms.famillecollet.com/>) or [EPEL](<http://fedoraproject.org/wiki/EPEL>) to\r\nsatisfy additional dependencies.\r\n\r\n## Raspbian\r\n\r\nAs an experiment we offer a Raspbian and brought the appserver to an ARM environment. What should\r\nwe say, it worked! :D With `os.distribution` = raspbian you might give it a try and build it\r\nyourself. Plan for at least 5 hours though, as we currently do not offer prepared install package.\r\n\r\n# Basic Usage\r\n\r\nThe appserver will automatically start after your installation wizard (or package manager) finishes\r\nthe setup. You can use it without limitations after installation is completed..\r\n\r\nBelow you can find basic instructions on how to make use of the appserver. After the installation,\r\nyou might want to have a look at the example application, which is also included with the installation. You can reach the app at `http://127.0.0.1:9080/example`\r\n\r\nStart your favorite browser and have a look at what appserver can do. :) To enter the site, use\r\nthe default login `appserver/appserver.i0`.\r\n\r\n## Start and Stop Scripts\r\n\r\nThere are several standalone processes, which are needed for the proper\r\nfunctioning of different features within appserver.\r\n\r\nThere are start and stop scripts included in appserver for all *nix like operating systems.\r\nThese work the same as on any other *nix systems. They are:\r\n\r\n* `appserver`: The main process which will start the appserver itself\r\n\r\n* `appserver-php5-fpm`: php-fpm + appserver configuration. Our default FastCGI backend. Other FCGI system can be added the same way.\r\n\r\n* `appserver-watcher`: A watchdog which monitors filesystem changes and manages appserver restarts\r\n\r\nOn a normal system, all three of these processes should run to enable the full feature set. To\r\nultimately run the appserver, only the appserver process is needed. However, you will miss simple on-the-fly\r\ndeployment (`appserver-watcher`) and might have problems with legacy applications.\r\n\r\nDepending on the FastCGI backend you want to use, you might ditch `appserver-php5-fpm` for other\r\nprocesses e.g. you could also use an [hhvm](http://hhvm.com/) backend.\r\n\r\nCurrently we support three different types of init scripts, which support the commands `start`, `stop`,\r\n`status` and `restart` (additional commands might be available on other systems).\r\n\r\n**Mac OS X (LAUNCHD)**\r\nThe LAUNCHD launch daemons are located within the appserver installation at `/opt/appserver/sbin`.\r\nThey can be used with the schema `/opt/appserver/sbin/<DAEMON> <COMMAND>`\r\n\r\n**Debian, Raspbian, CentOS, ...(SystemV)**\r\nCommonly known and located in `/etc/init.d/` they too support the commands mentioned above provided\r\nin the form `/etc/init.d/<DAEMON> <COMMAND>`.\r\n\r\n**Fedora, ... (systemd)**\r\nsystemd init scripts can be used using the `systemctl` command with the syntax `systemctl <COMMAND> <DAEMON>`.\r\n\r\n**Windows**\r\n\r\nOn Windows we sadly do not offer any of these scripts. After the installation, you can start the\r\nApplication Server with the ``server.bat`` file located within the root directory of your installation.\r\nBest thing to do would be starting a command prompt as an administrator and run the following commands\r\n(assuming default installation path):\r\n\r\n```\r\nC:\\Windows\\system32>cd \"C:\\Program Files\\appserver\"\r\nC:\\Program Files\\appserver>server.bat\r\n```\r\n\r\n# HTTP(S) Server\r\n\r\nThe configuration of the HTTP(S) Server itself is mostly self-explanatory, so just have a look at the default config\r\nfile and, if you'd like, try to change the settings.\r\nPlease make sure you restart the appserver after making any changes. :)\r\nA detailed overview of all configuration settings will follow ...\r\n\r\n## Configure a Virtual Host\r\n\r\nUsing virtual hosts, you can extend the default server configuration and produce a host specific\r\nenvironment for your app to run.\r\n\r\nYou can do so by adding a virtual host configuration to your global server configuration file. See\r\nthe example for a XML based configuration below:\r\n\r\n```xml\r\n<virtualHosts>\r\n  <virtualHost name=\"example.local\">\r\n    <params>\r\n      <param name=\"admin\" type=\"string\">\r\n        admin@appserver.io\r\n      </param>\r\n      <param name=\"documentRoot\" type=\"string\">\r\n        /opt/appserver/webapps/example\r\n      </param>\r\n    </params>\r\n  </virtualHost>\r\n</virtualHosts>\r\n```\r\n\r\nThe above configuration sits within the server element and opens up the virtual host `example.local`\r\nwhich has a different document root than the global configuration has. The virtual host is born. :-)\r\n\r\nThe `virtualHost` element can hold params, rewrite rules or environment variables which are only\r\navailable for the host specifically.\r\n\r\n## Configure your Environment Variables\r\n\r\nYou can set environment variables using either the global or the virtual host based configuration.\r\nThe example below shows a basic usage of environment variables in XML format.\r\n\r\n```xml\r\n<environmentVariables>\r\n  <environmentVariable\r\n    condition=\"\"\r\n    definition=\"EXAMPLE_VAR=example\" />\r\n  <environmentVariable\r\n    condition=\"Apple@$HTTP_USER_AGENT\"\r\n    definition=\"USER_HAS_APPLE=true\" />\r\n</environmentVariables>\r\n```\r\n\r\nThere are several ways in which this feature is used. You can get a rough idea when having a\r\nlook at Apache modules [mod_env](<http://httpd.apache.org/docs/2.2/mod/mod_env.html>) and\r\n[mod_setenvif](<http://httpd.apache.org/docs/2.2/mod/mod_setenvif.html>) which we adopted.\r\n\r\nYou can make definitions of environment variables dependent on REGEX based conditions which will\r\nbe performed on so called backreferences. These backreferences are request related server variables\r\nlike `HTTP_USER_AGENT`.\r\n\r\nA condition has the format `<REGEX_CONDITION>@$<BACKREFERENCE>`. If the condition is empty the\r\nenvironment variable will be set every time.\r\n\r\nThe definition you can use has the form `<NAME_OF_VAR>=<THE_VALUE_TO_SET>`. The definition has\r\nsome specialities too:\r\n\r\n- Setting a var to `null` will unset the variable if it existed before\r\n- You can use backreferences for the value you want to set as well. But those are limited to\r\n  environment variables of the PHP process\r\n- Values will be treated as strings\r\n\r\n# Servlet-Engine\r\n\r\nOriginally Java Servlets were Java's counterpart to other dynamic web technologies like PHP or the\r\nMicrosoft .NET platform. In contrast to PHP, a Servlet written in Java is not a script that will\r\nbe interpreted per request. Instead, it is a class, which is instantiated, when the Servlet Engine starts up.\r\nThis means, the servlet class is already in memory and stays in memory.\r\n\r\n> In most cases, this is a major advantage compared to the common PHP way to constantly reload the script on each\r\n> request. Since most PHP applications are based on frameworks like Symfony or Laravel have grown\r\n> immensly during the last few years, the reloading of all the script files required by the application,\r\n> slows down performance considerably. This is one of the reasons why caching is a major\r\n> part of all good PHP frameworks. On one hand, caching improves performance enough so\r\n> the application responds to the request in an acceptable timeframe. On the other hand, it is also the\r\n> origin of many problems, such as how to invalidate parts of the cache during an applications\r\n> runtime.\r\n\r\nServlets enable you to implement your application logic as you normally would, but without the need to worry about the expensive\r\nreloading process, which is common to normal PHP applications. A Servlet is a super\r\nfast and simple way to implement an entry point to handle HTTP requests, which allow you to\r\nexecute all performance critical tasks, like bootstrapping (with a simple method called `init()`), when\r\nthe Servlet Engine starts up.\r\n\r\n## What is a Servlet\r\n\r\nA Servlet is a simple class that has to extend from `AppserverIo\\Psr\\Servlet\\Http\\HttpServlet`.\r\nYour application logic can then be implemented by overwriting the `service()` method or better\r\nby overwriting the request specific methods like `doGet()` if you want to handle a GET request.\r\n\r\n## Create a simple Servlet\r\n\r\nLet's write a simple example and start with a famous `Hello World` servlet\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\nuse AppserverIo\\Psr\\Servlet\\ServletConfigInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServlet;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface;\r\n\r\n/**\r\n * This is the famous 'Hello World' as servlet implementation.\r\n *\r\n * @Route(name=\"helloWorld\",\r\n *        displayName=\"I'm the 'Hello World!' servlet\",\r\n *        description=\"A annotated 'Hello World!' servlet implementation.\",\r\n *        urlPattern={\"/helloWorld.do\", \"/helloWorld.do*\"})\r\n */\r\nclass HelloWorldServlet extends HttpServlet\r\n{\r\n\r\n  /**\r\n   * The text to be rendered.\r\n   *\r\n   * @var string\r\n   */\r\n  protected $helloWorld = '';\r\n\r\n  /**\r\n   * Initializes the servlet with the passed configuration.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\ServletConfigInterface $config\r\n   *   The configuration to initialize the servlet with\r\n   *\r\n   * @return void\r\n   */\r\n  public function init(ServletConfigInterface $config)\r\n  {\r\n\r\n    // call parent method\r\n    parent::init($config);\r\n\r\n    // prepare the text here\r\n    $this->helloWorld = 'Hello World!';\r\n\r\n    // @todo Do all the bootstrapping here, because this method will\r\n    //       be invoked only once when the Servlet Engines starts up\r\n  }\r\n\r\n  /**\r\n   * Handles a HTTP GET request.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface  $servletRequest\r\n   *   The request instance\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface $servletResponse\r\n   *   The response instance\r\n   *\r\n   * @return void\r\n   * @see \\AppserverIo\\Psr\\Servlet\\Http\\HttpServlet::doGet()\r\n   */\r\n  public function doGet(\r\n    HttpServletRequestInterface $servletRequest,\r\n    HttpServletResponseInterface $servletResponse)\r\n  {\r\n    $servletResponse->appendBodyStream($this->helloWorld);\r\n  }\r\n}\r\n```\r\n\r\nand save it as `/opt/appserver/webapps/myapp/WEB-INF/classes/Namespace/Module/HelloWorldServlet.php`.\r\n\r\nIs that all? Yes! [Restart](#start-and-stop-scripts) the application server and open\r\n`http://127.0.0.1:9080/myapp/helloWorld.do` in your favorite browser, and ... vóila :)\r\n\r\n> A restart is always required since you changed code in your Servlet, because the Servlet\r\n> will be loaded and initialized when the the application server starts. Without a restart\r\n> the application server will not know you had made any changes.\r\n\r\n# Annotations\r\n\r\nSince one of our main goals is to make configuration as simple as possible, we decided to use\r\nannotations wherever possible. As annotations are not supported natively by PHP, we provide\r\nannotation support over our [lang](https://github.com/appserver-io/lang) package.\r\n\r\nBeside the use of annotations in our application server components, it will also be possible to extend your\r\napplication with annotations by using the functionality appserver delivers out-of-the-box.\r\n\r\nIf you, for example, think about extending the actions of the controller component in your\r\nMVC framework with a @Route annotation, you can do that in the following way\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\nuse AppserverIo\\Appserver\\Lang\\Reflection\\ReflectionClass;\r\nuse AppserverIo\\Appserver\\Lang\\Reflection\\ReflectionAnnotation;\r\n\r\nclass Route extends ReflectionAnnotation\r\n{\r\n\r\n  /**\r\n   * Returns the value of the name attribute.\r\n   *\r\n   * @return string The annotations name attribute\r\n   */\r\n  public function getPattern()\r\n  {\r\n    return $this->values['pattern'];\r\n  }\r\n}\r\n\r\nclass IndexController\r\n{\r\n\r\n  /**\r\n   * Default action implementation.\r\n   *\r\n   * @return void\r\n   * @Route(pattern=\"/index/index\")\r\n   */\r\n  public function indexAction()\r\n  {\r\n    // do something here\r\n  }\r\n}\r\n\r\n// create a reflection class to load the methods annotation\r\n$reflectionClass = new ReflectionClass('IndexController');\r\n$reflectionMethod = $reflectionClass->getMethod('indexAction');\r\n$reflectionAnnotation = $reflectionMethod->getAnnotation('Route');\r\n$pattern = $reflectionAnnotation->newInstance()->getPattern();\r\n```\r\n\r\nMost of the annotation implementations provided by our [Enterprise Beans](https://github.com/appserver-io-psr/epb)\r\nPSR and used for [Dependency Injection](#dependency-injection), which will be described below,\r\nare based on that annotation implementation.\r\n\r\n# Dependency Injection\r\n\r\nDependency Injection(DI) enables developers to write cleaner, reusable and maintainable\r\ncode with less coupling by injecting necessary instances at runtime, instead of instantiating them in\r\nthe class itself. Within the application server, each application has its own scope and therefore its\r\nown dependency injection container. This prevents your application from fatal errors like `Cannot redeclare class ...`.\r\n\r\n## What can be injected\r\n\r\nGenerally everything! The application server itself doesn't use DI, instead it provides DI as a\r\nservice for the applications running within it. But, before you can let the DI container inject an\r\ninstance to your class, you have to register it. Registering a class for DI is pretty simple. To\r\nregister a class in the DI container the most common way is to use annotations.\r\n\r\n```php\r\n\r\nnamespace Namespace\\Modulename\r\n\r\n/**\r\n * @Stateless(name=\"MyStatefulSessionBean\")\r\n */\r\nclass MyStatefulSessionBean\r\n{\r\n}\r\n```\r\n\r\nWhen the application server starts, it parses the `META-INF/classes` and `WEB-INF/classes` folder\r\nclasses with supported annotations. If a class is found, the class will be registered in the\r\napplication servers naming directory under the name you specify in the annotations `name` Attribute,\r\nin this example `MyStatefulSessionBean`.\r\n\r\n## How to inject an instance\r\n\r\nBasically DI can be a manual process where you `inject` an instance, needed by another class by\r\npassing it to the constructor. Inside the application server, the injection is a process you can't\r\nsee, it's more a kind of magic that happens behind the scenes. So instead of manually passing the\r\nnecessary instances to a classes constructor, the DI container will do that for you.\r\n\r\nYou simply have to tell the DI container what you need. Let's have a look at how that is done.\r\n\r\n### Property Injection\r\n\r\nThe first possibility we have is to annotate a class property\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\nuse AppserverIo\\Psr\\Servlet\\ServletConfigInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServlet;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface;\r\n\r\n/**\r\n * This is the famous 'Hello World' as servlet implementation.\r\n */\r\nclass HelloWorldServlet extends HttpServlet\r\n{\r\n\r\n  /**\r\n   * The SessionBean instance we want to have injected.\r\n   *\r\n   * @var \\Namespace\\Modulename\\MyStatefulSessionBean\r\n   * @EnterpriseBean(name=\"MyStatefulSessionBean\")\r\n   */\r\n  protected $myStatefulSessionBean;\r\n\r\n  /**\r\n   * The text to be rendered.\r\n   *\r\n   * @var string\r\n   */\r\n  protected $helloWorld = '';\r\n\r\n  /**\r\n   * Initializes the servlet with the passed configuration.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\ServletConfigInterface $config\r\n   *   The configuration to initialize the servlet with\r\n   *\r\n   * @return void\r\n   */\r\n  public function init(ServletConfigInterface $config)\r\n  {\r\n\r\n    // call parent method\r\n    parent::init($config);\r\n\r\n    // prepare the text here\r\n    $this->helloWorld = 'Hello World!';\r\n\r\n    // @todo Do all the bootstrapping here, because this method will\r\n    //       be invoked only once when the Servlet Engines starts up\r\n  }\r\n\r\n  /**\r\n   * Handles a HTTP GET request.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface  $servletRequest\r\n   *   The request instance\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface $servletResponse\r\n   *   The response instance\r\n   *\r\n   * @return void\r\n   * @see \\AppserverIo\\Psr\\Servlet\\Http\\HttpServlet::doGet()\r\n   */\r\n  public function doGet(\r\n    HttpServletRequestInterface $servletRequest,\r\n    HttpServletResponseInterface $servletResponse)\r\n  {\r\n    $servletResponse->appendBodyStream($this->helloWorld);\r\n  }\r\n}\r\n```\r\n\r\nWith the `name` attribute of the `@EnterpriseBean` annotation, you have the possibility to specify the\r\nname of the bean you registered before by annotating it. A more detailed description about the\r\navailable annotations is part of the [Persistence-Container](#persistence-container).\r\n\r\n### Setter Injection\r\n\r\nThe second possibility to inject an instance is setter injection.\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\nuse AppserverIo\\Psr\\Servlet\\ServletConfigInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServlet;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface;\r\n\r\n/**\r\n * This is the famous 'Hello World' as servlet implementation.\r\n */\r\nclass HelloWorldServlet extends HttpServlet\r\n{\r\n\r\n  /**\r\n   * The SessionBean instance we want to have injected.\r\n   *\r\n   * @var \\Namespace\\Modulename\\MyStatefulSessionBean\r\n   */\r\n  protected $myStatefulSessionBean;\r\n\r\n  /**\r\n   * The text to be rendered.\r\n   *\r\n   * @var string\r\n   */\r\n  protected $helloWorld = '';\r\n\r\n  /**\r\n   * Initializes the servlet with the passed configuration.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\ServletConfigInterface $config\r\n   *   The configuration to initialize the servlet with\r\n   *\r\n   * @return void\r\n   */\r\n  public function init(ServletConfigInterface $config)\r\n  {\r\n\r\n    // call parent method\r\n    parent::init($config);\r\n\r\n    // prepare the text here\r\n    $this->helloWorld = 'Hello World!';\r\n\r\n    // @todo Do all the bootstrapping here, because this method will\r\n    //       be invoked only once when the Servlet Engines starts up\r\n  }\r\n\r\n  /**\r\n   * Handles a HTTP GET request.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface  $servletRequest\r\n   *   The request instance\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface $servletResponse\r\n   *   The response instance\r\n   *\r\n   * @return void\r\n   * @see \\AppserverIo\\Psr\\Servlet\\Http\\HttpServlet::doGet()\r\n   */\r\n  public function doGet(\r\n    HttpServletRequestInterface $servletRequest,\r\n    HttpServletResponseInterface $servletResponse)\r\n  {\r\n    $servletResponse->appendBodyStream($this->helloWorld);\r\n  }\r\n\r\n  /**\r\n   * Injects the session bean by its setter method.\r\n   *\r\n   * @param \\Namespace\\Modulename\\MyStatefulSessionBean $myStatefulSessionBean\r\n   *   The instance to inject\r\n   * @EnterpriseBean(name=\"MyStatefulSessionBean\")\r\n   */\r\n  public function setMySessionBean(MyStatefulSessionBean $myStatefulSessionBean)\r\n  {\r\n    $this->myStatefulSessionBean = $myStatefulSessionBean;\r\n  }\r\n}\r\n```\r\n\r\n> This method is the preferred one, because it will be refactored not to use reflection in further\r\n> versions.\r\n\r\n# Persistence-Container\r\n\r\nAs described in the introduction, the application is designed inside a runtime environment, like\r\nan application server as appserver.io is. The following example gives you a short introduction\r\non how you can create a stateful session bean and the way you can invoke it's method on the client side.\r\n\r\nFirst thing you can to do is create your SessionBean. What is a SessionBean? A SessionBean is basically a plain PHP class.\r\nHowever, you MUST not instantiate it directly, because the application server takes care of its complete\r\nlifecycle. Therefore, if you need an instance of a SessionBean, you must ask the application server\r\nto give you an instance.\r\n\r\nThe persistence container will give you a proxy to the session bean that allows you to\r\ninvoke all methods the SessionBean provides, just like you would do with a normal instance. But,\r\nthe proxy also allows you to call this method over a network as remote method call. Using the\r\npersistence container client makes it easy for you, if your SessionBean is on the same\r\napplication server instance or even on another appserver in your network. This gives you the possibility\r\nto distribute the components of your application over your network, which means a great and\r\nseamless scalability.\r\n\r\nYou have to tell the persistence container what type of SessionBean you would like to have. This MUST\r\nbe done by simply adding an annotation to the class doc block. The possible annotations therefore\r\nare\r\n\r\n* @Singleton\r\n* @Stateless\r\n* @Stateful\r\n\r\n\r\n## @Singleton SessionBean\r\n\r\nA SessionBean with a @Singleton annotation will be created only one time for each application.\r\nThis means, whenever you'll request an instance, you'll receive the same one. If you set a\r\nvariable in the SessionBean, it'll be available until you'll overwrite it, or the application\r\nserver has been restarted.\r\n\r\n## @Stateless SessionBean\r\n\r\nContrary to a singleton session bean, a SessionBean with a @Stateless annotation will always\r\nbe instantiated, when you request it. It has NO state, and is only valid for the time you invoke a method on\r\nit.\r\n\r\n## @Stateful SessionBean\r\n\r\nThe @Stateful SessionBean is a comprimise between the two other types. It is stateful for the session\r\nwith the ID you pass to the client, when you request the instance. A stateful SessionBean is\r\nuseful, for instance, if you want to implement something like a shopping cart. If you declare the shopping cart\r\ninstance, a class member of your SessionBean makes it persistent for your session lifetime.\r\n\r\n## Example\r\n\r\nThe following example shows you a really simple implementation of a stateful SessionBean providing\r\na counter that'll be raised whenever you call the `raiseMe()` method.\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\n/**\r\n * This is demo implementation of stateful session bean.\r\n *\r\n * @Stateful\r\n */\r\nclass MyStatefulSessionBean\r\n{\r\n\r\n  /**\r\n   * Stateful counter that exists as long as your session exists.\r\n   *\r\n   * @var integer\r\n   */\r\n  protected $counter = 0;\r\n\r\n  /**\r\n   * Example method that raises the counter by one each time you'll invoke it.\r\n   *\r\n   * @return integer The raised counter\r\n   */\r\n  public function raiseMe()\r\n  {\r\n    return $this->counter++;\r\n  }\r\n}\r\n```\r\n\r\nSave the SessionBean in `/opt/appserver/myapp/META-INF/classes/Namespace/Module/MyStatefulSessionBean.php`.\r\n\r\nAs described above, you MUST not instantiate it directly. To request an instance of the SessionBean\r\nyou MUST use the persistence container client. With the `lookup()` method you'll receive a proxy to\r\nyour SessionBean, on that you can invoke the methods as you can do with a real instance.\r\n\r\nTo develop our HelloWorldServlet further, let's raise the counter with each request to the servlet. To\r\ndo this, we have to refactor the `doGet()` method\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\nuse AppserverIo\\Psr\\Servlet\\ServletConfigInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServlet;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface;\r\n\r\n/**\r\n * This is the famous 'Hello World' as servlet implementation.\r\n */\r\nclass HelloWorldServlet extends HttpServlet\r\n{\r\n\r\n  /**\r\n   * The text to be rendered.\r\n   *\r\n   * @var string\r\n   */\r\n  protected $helloWorld = '';\r\n\r\n  /**\r\n   * We want to have an instance of our stateful session bean injected.\r\n   *\r\n   * @var \\Namespace\\Module\\MyStatefulSessionBean\r\n   */\r\n   protected $myStatefulSessionBean;\r\n\r\n  /**\r\n   * Initializes the servlet with the passed configuration.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\ServletConfigInterface $config\r\n   *   The configuration to initialize the servlet with\r\n   *\r\n   * @return void\r\n   */\r\n  public function init(ServletConfigInterface $config)\r\n  {\r\n\r\n    // call parent method\r\n    parent::init($config);\r\n\r\n    // prepare the text here\r\n    $this->helloWorld = 'Hello World! (has been invoked %d times)';\r\n\r\n    // @todo Do all the bootstrapping here, because this method will\r\n    //       be invoked only once when the Servlet Engines starts up\r\n  }\r\n\r\n  /**\r\n   * Handles a HTTP GET request.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface  $servletRequest\r\n   *   The request instance\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface $servletResponse\r\n   *   The response instance\r\n   *\r\n   * @return void\r\n   * @see \\AppserverIo\\Psr\\Servlet\\Http\\HttpServlet::doGet()\r\n   */\r\n  public function doGet(\r\n    HttpServletRequestInterface $servletRequest,\r\n    HttpServletResponseInterface $servletResponse)\r\n  {\r\n\r\n    // start a session, because our @Stateful SessionBean\r\n    // needs thesession-ID to bound to\r\n    $servletRequest->getSession()->start(true);\r\n\r\n    // render 'Hello World! (has been invoked 1 times)'\r\n    // for example - after the first request\r\n    $servletResponse->appendBodyStream(\r\n      sprintf($this->helloWorld, $this->myStatefulSessionBean->raiseMe())\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Injects the session bean by its setter method.\r\n   *\r\n   * @param \\Namespace\\Modulename\\MyStatefulSessionBean $myStatefulSessionBean\r\n   *   The instance to inject\r\n   * @EnterpriseBean(name=\"MyStatefulSessionBean\")\r\n   */\r\n  public function setMySessionBean(MyStatefulSessionBean $myStatefulSessionBean)\r\n  {\r\n    $this->myStatefulSessionBean = $myStatefulSessionBean;\r\n  }\r\n}\r\n```\r\n\r\nThat's it!\r\n\r\n> As we use a @Stateful SessionBean in this example, we MUST start a session so the persistence container can\r\n> bind the SessionBean. If you would have used a @Singleton SessionBean, the effect would be the\r\n> practically the same, but it would have been possible to start a SessionBean per session. As a consequence, each Servlet that\r\n> invokes the `raiseMe()` method on the singleton SessionBean would raise the counter, meaning possibly every call to the server would raise the counter and not each particular call for a particular session.\r\n\r\n# Message-Queue\r\n\r\nA Message-Queue provides the possibility to process long running tasks in an encapsulated context.\r\nFor example, if you want to import a lot of products in your online shop, you can send a\r\nmessage to the Message-Queue, which then will start the import process in the background without\r\npreventing the calling process to continue.\r\n\r\n> Using a Message-Queue gives you the power to use threads without taking care of the pitfalls!\r\n\r\n## Got mail!\r\n\r\nBefore we can send a message, we have to specify what should happen, when we receive one! The\r\nMessage-Queue allows you to specify so called `Queues`. Each `Queue` can have a receiver, which\r\nmust be a so called `MessageBean`. A `MessageBean` is very similar to a [@Stateless SessionBean](#@stateless-session-bean),\r\nbut has only a single point of entry, the `onMessage()` message method. Whenever a message\r\nis sent to the queue, the Message-Queue simply pushes it onto the stack. In the background, a\r\n`QueueWorker` is running in another context and queries the stack for new messages. If a new\r\nmessage is available, it will be pulled from the stack, as a new instance of the receiver, which the `Queue`\r\nis bound to and will be instantiated to pass the message for processing.\r\n\r\nSo let us create a simple `Queue` with\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<message-queues>\r\n  <message-queue type=\"ImportReceiver\">\r\n    <destination>pms/import</destination>\r\n  </message-queue>\r\n</message-queues>\r\n```\r\n\r\nand save this in a file called `/opt/appserver/myapp/META-INF/message-queues.xml`. The next thing\r\nwe need is the `MessageBean` that allows us to receive and process a message in a separate thread.\r\n\r\n```php\r\n\r\nnamespace Namespace\\Modulename;\r\n\r\nuse AppserverIo\\Appserver\\MessageQueue\\Receiver\\AbstractReceiver;\r\n\r\n/**\r\n * @MessageDriven\r\n */\r\nclass ImportReceiver extends AbstractReceiver\r\n{\r\n\r\n  /**\r\n   * Will be invoked when a new message for this message bean will be available.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\MessageQueueProtocol\\Message $message   A message this message bean is listen for\r\n   * @param string                                        $sessionId The session ID\r\n   *\r\n   * @return void\r\n   * @see \\AppserverIo\\Psr\\MessageQueueProtocol\\Receiver::onMessage()\r\n   */\r\n  public function onMessage(Message $message, $sessionId)\r\n  {\r\n    $data = array_map('str_getcsv', file($message->getMessage()->__toString()));\r\n    foreach ($data as $row) {\r\n      // write the data to the database here\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n> Please note: beside the functionality you have to implement with the `onMessage()`\r\n> message method, you must also use the annotation `@MessageDriven` on your class. You MUST annotate the MessageBean in this fashion,\r\n> in order for the container to know about and register it on startup.\r\n\r\nPretty simple for running your import in a separate thread? But what about sending a message to\r\nthis `Queue`?\r\n\r\n## Send a message\r\n\r\nMessages are POPOs (Plain Old PHP Objects) that can be sent over the network. So if you want to send a message, you have\r\nto initialize the Message-Queue Client and specify which `Queue` you want to send the message to.\r\n\r\nAgain, we will extend our `Servlet` to start an import process on a POST request\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\nuse AppserverIo\\Psr\\Servlet\\ServletConfigInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServlet;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface;\r\nuse AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface;\r\nuse AppserverIo\\Psr\\MessageQueueProtocol\\Messages\\StringMessage;\r\n\r\n/**\r\n * This is the famous 'Hello World' as servlet implementation.\r\n */\r\nclass HelloWorldServlet extends HttpServlet\r\n{\r\n\r\n  /**\r\n   * The name of the request parameter with the name of the CSV\r\n   * file containing the data to be imported.\r\n   *\r\n   * @var string\r\n   */\r\n  const PARAMETER_FILENAME = 'filename';\r\n\r\n  /**\r\n   * The text to be rendered.\r\n   *\r\n   * @var string\r\n   */\r\n  protected $helloWorld = '';\r\n\r\n  /**\r\n   * We want to have an instance of our stateful session bean injected.\r\n   *\r\n   * @var \\Namespace\\Module\\MyStatefulSessionBean\r\n   */\r\n   protected $myStatefulSessionBean;\r\n\r\n  /**\r\n   * The application instance.\r\n   *\r\n   * @var \\AppserverIo\\Psr\\Application\\ApplicationInterface\r\n   */\r\n  protected $application;\r\n\r\n  /**\r\n   * The queue session to send a message with.\r\n   *\r\n   * @var \\AppserverIo\\MessageQueueClient\\QueueSession\r\n   * @Resource(name=\"pms/import\")\r\n   */\r\n  protected $queueSender;\r\n\r\n  /**\r\n   * Initializes the servlet with the passed configuration.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\ServletConfigInterface $config\r\n   *   The configuration to initialize the servlet with\r\n   *\r\n   * @return void\r\n   */\r\n  public function init(ServletConfigInterface $config)\r\n  {\r\n\r\n    // call parent method\r\n    parent::init($config);\r\n\r\n    // prepare the text here\r\n    $this->helloWorld = 'Hello World! (has been invoked %d times)';\r\n\r\n    // @todo Do all the bootstrapping here, because this method will\r\n    //       be invoked only once when the Servlet Engines starts up\r\n  }\r\n\r\n  /**\r\n   * Handles a HTTP GET request.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletRequestInterface  $servletRequest\r\n   *   The request instance\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\HttpServletResponseInterface $servletResponse\r\n   *   The response instance\r\n   *\r\n   * @return void\r\n   * @see \\AppserverIo\\Psr\\Servlet\\Http\\HttpServlet::doGet()\r\n   */\r\n  public function doGet(\r\n    HttpServletRequestInterface $servletRequest,\r\n    HttpServletResponseInterface $servletResponse)\r\n  {\r\n\r\n    // start a session, because our @Stateful SessionBean\r\n    // needs thesession-ID to bound to\r\n    $servletRequest->getSession()->start(true);\r\n\r\n    // render 'Hello World! (has been invoked 1 times)'\r\n    // for example - after the first request\r\n    $servletResponse->appendBodyStream(\r\n      sprintf($this->helloWorld, $this->myStatefulSessionBean->raiseMe())\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handles a HTTP POST request.\r\n   *\r\n   * Loads the filename containing the CSV data we want to import as request\r\n   * parameter and sends it, wrapped as message, to the queue.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\ServletRequest  $servletRequest\r\n   *   The request instance\r\n   * @param \\AppserverIo\\Psr\\Servlet\\Http\\ServletResponse $servletResponse\r\n   *   The response instance\r\n   *\r\n   * @return void\r\n   * @see \\AppserverIo\\Psr\\Servlet\\Http\\HttpServlet::doPost()\r\n   * @throws \\AppserverIo\\Psr\\Servlet\\ServletException\r\n   *   Is thrown because the request method is not implemented yet\r\n   */\r\n  public function doPost(\r\n    HttpServletRequestInterface $servletRequest,\r\n    HttpServletResponseInterface $servletResponse)\r\n  {\r\n\r\n    // load the filename we have to import\r\n    $filename = $servletRequest->getParameter(\r\n      HelloWorldServlet::PARAMETER_FILENAME\r\n    );\r\n\r\n    // send the name of the file to import to the message queue\r\n    $this->queueSender->send(new StringMessage($filename), false);\r\n  }\r\n\r\n  /**\r\n   * Injects the session bean by its setter method.\r\n   *\r\n   * @param \\Namespace\\Modulename\\MyStatefulSessionBean $myStatefulSessionBean\r\n   *   The instance to inject\r\n   * @EnterpriseBean(name=\"MyStatefulSessionBean\")\r\n   */\r\n  public function setMySessionBean(MyStatefulSessionBean $myStatefulSessionBean)\r\n  {\r\n    $this->myStatefulSessionBean = $myStatefulSessionBean;\r\n  }\r\n\r\n  /**\r\n   * Injects the application instance by its setter method.\r\n   *\r\n   * @param \\AppserverIo\\Psr\\Application\\ApplicationInterface $application\r\n   *   The application instance to inject\r\n   * @Resource(name=\"ApplicationInterface\")\r\n   */\r\n  public function setApplication(ApplicationInterface $application)\r\n  {\r\n    $this->application = $application;\r\n  }\r\n}\r\n```\r\n\r\n> To make the process easier, you can use the `@Resource` annotation to let the container inject a sender\r\n> instance, which we can use to send the name of the file containing the data to the `Queue`.\r\n\r\n# Timer-Service\r\n\r\nIn most of your projects you have the need to schedule tasks to be processed at regular intervals\r\nor at a given dates in the future. As PHP itself is a scripting language, it lacks such functionality\r\nand developers usually end up using utilities like CRON, when working on Mac OS X or a Linux distribution, which also requires low level access to the server. And, if you\r\nare working on Windows, it's even a bit more complicated. There is a tool called Scheduler in Windows, but\r\nusing it is not as simple to as CRON. Neither of these options are really \"programmable\" and this is where a Timer Service comes into the game and makes scheduling tasks within your appserver application a dream come true..\r\n\r\nAs CRON does, the Timer Service allows you to schedule processing of your functional tasks at a given\r\ndate or in regular intervals. In contrast to CRON however, it allows you to schedule processing the methods\r\nof your Beans (which remember, are already processed and stored in memory).\r\n\r\nHow can this be done?\r\n\r\nYou might know the answer by now, simply by adding an annotation to your method, as follows\r\n\r\n```php\r\n\r\nnamespace Namespace\\Modulename;\r\n\r\n/**\r\n * @Singleton(name=\"ASingletonProcessor\")\r\n */\r\nclass ASingletonProcessor extends \\Stackable\r\n{\r\n\r\n  /**\r\n   * A dummy method invoked by the container upon timer schedule.\r\n   *\r\n   * @param TimerInterface $timer The timer instance\r\n   *\r\n   * @return void\r\n   * @Schedule(dayOfMonth=EVERY, month=EVERY, year=EVERY, minute=EVERY, hour=EVERY)\r\n   */\r\n  public function invokedByTimer(TimerInterface $timer)\r\n  {\r\n    // do something here every minute\r\n  }\r\n}\r\n```\r\n\r\nThe `@Schedule` annotation on the `invokedByTimer()` method schedules the invocation of this\r\nmethod every minute without the need to have a CRON configured or running. Such `Timers` can\r\nalso be created programatically. If you want to know more about this functionality, have a look at our [example](https://github.com/appserver-io-apps/example).\r\n\r\n# AOP\r\n\r\nAlthough in its early days, AOP used to be a buzzword. It has, however, become a development paradigm followed by many of the PHP frameworks out there today. It has been followed for many years already by other languages like Java. Since there is actually no stable PECL extension, nor is AOP part of the PHP core, creating such an environment creates a number of challenges to make applications based on AOP to perform well. Because of its nature, AOP needs to be deeply weaved into your code. Most of the solutions available for PHP solve that by generating so called `proxy classes` that wrap the original methods and allow to weave the advices before, after or around the original implementation.\r\n\r\nSince in appserver, we're in a multi-threaded environment and performance is one of our main goals, we were not\r\nable to use anyone one of the available solutions. As we also need to generate proxy classes, we decided\r\nto do that through an autoloader. And since we have enabled an autoloader as part of the appserver.io distribution, you\r\ndon't have to configure anything to use AOP in your code.\r\n\r\n## How to add an Advice\r\n\r\nIntegrating AOP in your app can be done in two ways. The first one is to define the pointcuts (and also\r\nadvices if you like) in the same class they will get woven into, the second method is to separate them. In the following section we want to describe the second approach.\r\n\r\nLet's say we want to log all GET requests on our HelloWorldServlet without adding any\r\ncode to the servlet itself. To do this, we first have to create an Aspect class like\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\n/**\r\n * @Aspect\r\n */\r\nclass LoggerAspect\r\n{\r\n\r\n  /**\r\n   * Pointcut which targets all GET requests for all servlets\r\n   *\r\n   * @return void\r\n   * @Pointcut(\"call(\\Namespace\\Module\\*->doGet())\")\r\n   */\r\n  public function allDoGet()\r\n  {\r\n  }\r\n\r\n  /**\r\n   * Advice used to log the call to any advised method.\r\n   *\r\n   * @param \\AppserverIo\\Doppelgaenger\\Interfaces\\MethodInvocationInterface $methodInvocation\r\n   *   Initially invoked method\r\n   *\r\n   * @return null\r\n   * @Before(\"pointcut(allIndexActions())\")\r\n   */\r\n  public function logInfoAdvice(MethodInvocationInterface $methodInvocation)\r\n  {\r\n\r\n    // load class and method name\r\n    $className = $methodInvocation->getStructureName();\r\n    $methodName = $methodInvocation->getName()\r\n\r\n    // log the method invocation\r\n    $methodInvocation->getContext()\r\n      ->getServletRequest()\r\n      ->getContext()\r\n      ->getInitialContext()\r\n      ->getSystemLogger()\r\n      ->info(\r\n        sprintf('The method %s::%s is about to be called', className, methodName)\r\n      );\r\n  }\r\n}\r\n```\r\n\r\nStore the class in `/opt/appserver/myapp/META-INF/classes/Namespace/Module/LoggerAspect` and\r\n[restart](#start-and-stop-scripts) the application server.\r\n\r\nTo see the the log message, open the console (Linux/Mac OS X) and enter\r\n\r\n```bash\r\n$ tail -f /opt/appserver/var/log/appserver-errors.log\r\n```\r\n\r\nThen open `http://127.0.0.1:9080/myapp/helloWorld.do` in your favorite browser, and have a look\r\nat the console.\r\n\r\n> AOP is a very powerful instrument to enrich your application with functionality with \"controlled\" coupling.\r\n> But as in most cases, great power comes with great responsibility. So, it is really\r\n> necessary to keep in mind, where your Aspect classes are and what they do. If not, someone\r\n> will wonder what happens and may need a good amount of time to figure out a problem. To avoid this, we'll\r\n> provide an XML based advice declaration in future versions.\r\n\r\n# Design-by-Contract\r\n\r\nBeside AOP, [Design-by-Contract](http://en.wikipedia.org/wiki/Design_by_contract) is another\r\ninteresting approach we support out-of-the-box, when you think about the architecture of your\r\nsoftware.\r\n\r\nFirst introduced by Bertrand Meyer in connection with his design of the Eiffel programming language,\r\nDesign-by-Contract allows you to define formal, precise and verifiable interface specifications of\r\nsoftware components.\r\n\r\nDesign-by-Contract extends the ordinary definition of classes, abstract classes and interfaces by\r\nadding pre-/postconditions and invariants referred to as `contracts`. As Design-by-Contract is, as\r\nis AOP, not part of the PHP core, we also use annotations to specify these contracts.\r\n\r\n## What can be done?\r\n\r\nAs stated above, this library aims to bring you the power of Design by Contract, an approach to make\r\nyour applications more robust and easier to debug. This contains basic features as:\r\n\r\n- Use your basic `DocBlock` annotations `@param` and `@return` as type hints (scalar and class/interface\r\n  based), including special features like `typed arrays` using e. g. `array<int>` (currently only works for collections with complex types)\r\n- Specify complex method contracts in PHP syntax using `@requires` as precondition and `@ensures` as\r\n  postcondition\r\n- Specify a state of validity for your classes (e.g. `$this->attribute !== null`) which will be true\r\n  all times using `@invariant`\r\n- The above (not including type safety) will be inherited by every child structure, strengthening your\r\n  object hierarchies\r\n- The library will warn you (exception or log message) on violations of these contracts\r\n\r\n## How does it work?\r\n\r\nWe use a system of autoloading and code creation to ensure our annotations will be enforced.\r\nThis features a 4 step process:\r\n\r\n- Autoloader : Handles autoloading and will know if contract enforcement is needed for a certain file.\r\n  If so (and the cache is empty) the call will be directed to the Generator/Parser Combo\r\n- Parser : Will parse the needed file using [`Tokenizer`](<http://www.php.net/manual/en/book.tokenizer.php>)\r\n  and provide information for further handling.\r\n- Generator : Will use stream filters to create a new file structure definition containing configured enforcement\r\n- Cache : Will allow us to omit Parser and Generator for future calls, to speed up usage significantly.\r\n\r\n## Usage\r\n\r\nSupposed, we want to make sure, that the counter in our stateful SessionBean will always be an integer, we can\r\ndefine a simple contract, therefore\r\n\r\n```php\r\n\r\nnamespace Namespace\\Module;\r\n\r\n/**\r\n * This is demo implementation of stateful session bean.\r\n *\r\n * @Stateful\r\n * @invariant is_integer($this->counter)\r\n */\r\nclass MyStatefulSessionBean\r\n{\r\n\r\n  /**\r\n   * Stateful counter that exists as long as your session exists.\r\n   *\r\n   * @var integer\r\n   */\r\n  protected $counter = 0;\r\n\r\n  /**\r\n   * Example method that raises the counter by one each time you'll invoke it.\r\n   *\r\n   * @return integer The raised counter\r\n   */\r\n  public function raiseMe()\r\n  {\r\n    return $this->counter++;\r\n  }\r\n}\r\n```\r\n\r\nDepending on your configuration, if a method would try to set a string on the counter variable, the\r\nDesign-by-Contract implementation would either throw an exception or write an error message to our\r\nlog file under `/opt/appserver/var/log/appserver-errors.log`.\r\n\r\n# Runtime Environment\r\n\r\nThe appserver.io runtime environment is delivered by the package [runtime](<https://github.com/appserver-io-php/runtime>).\r\nThis package  provides a runtime which is system independent and encloses a thread-safe\r\ncompiled PHP environment. Besides the most recent PHP 5.5.x version the package comes with following installed\r\nextensions:\r\n\r\n* [pthreads](http://github.com/appserver-io-php/pthreads)\r\n* [appserver](https://github.com/appserver-io/php-ext-appserver) (contains some replacement functions\r\n  which behave badly in a multi-threaded environment)\r\n\r\nAdditionally, the PECL extensions [XDebug](http://pecl.php.net/package/xdebug) and [ev](http://pecl.php.net/package/ev)\r\nare compiled as shared modules. `XDebug` is necessary to render detailed code coverage reports when\r\nrunning unit and integration tests. `ev` will be used to integrate a timer service in one of the future\r\nversions.\r\n\r\n# Configuration\r\n\r\nWe believe that the appserver should be highly configurable, so anyone interested can fiddle\r\naround with it. Therefore, we provide a central configuration file located at `/opt/appserver/etc/appserver.xml`.\r\n\r\nThis file contains the complete [architecture](#the-architecture) as an XML structure.\r\n\r\nSo if you want to change used components, introduce new services or scale the system by adding\r\nadditional servers you can do so with some lines of XML.You might have a look at a basic\r\n`appserver.xml`.\r\n\r\n## The Architecture\r\n\r\nIn this example we have a shortened piece of the `appserver.xml` file to understand how the\r\narchitecture is driven by configuration.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<appserver xmlns=\"http://www.appserver.io/appserver\">\r\n\r\n  <!-- define user, group and default umask applied when creating directories and files -->\r\n  <params>\r\n    <param name=\"user\" type=\"string\">_www</param>\r\n    <param name=\"group\" type=\"string\">staff</param>\r\n    <param name=\"umask\" type=\"string\">0002</param>\r\n  </params>\r\n\r\n  <containers>\r\n\r\n    <!-- by default we combine all servers in one container -->\r\n    <container name=\"combined-appserver\" type=\"AppserverIo\\Core\\GenericContainer\">\r\n      <description>\r\n        <![CDATA[\r\n          This is an example of a webserver container\r\n          that handles http requests in common way\r\n        ]]>\r\n      </description>\r\n      <deployment type=\"AppserverIo\\Appserver\\Core\\GenericDeployment\" />\r\n      <host\r\n        name=\"localhost\"\r\n        appBase=\"/webapps\"\r\n        serverAdmin=\"info@appserver.io\"\r\n        serverSoftware=\"appserver/1.0.0-beta (mac) PHP/5.5.16\" />\r\n\r\n        <servers>\r\n\r\n          <!-- this is the default configuration for the HTTP server -->\r\n          <server\r\n            name=\"http\"\r\n            type=\"\\AppserverIo\\Server\\Servers\\MultiThreadedServer\"\r\n            worker=\"\\AppserverIo\\Server\\Workers\\ThreadWorker\"\r\n            socket=\"\\AppserverIo\\Server\\Sockets\\StreamSocket\"\r\n            serverContext=\"\\AppserverIo\\Server\\Contexts\\ServerContext\"\r\n            requestContext=\"\\AppserverIo\\Server\\Contexts\\RequestContext\"\r\n            loggerName=\"System\">\r\n\r\n            <!-- define the parameters to configure the server instance -->\r\n            <params>\r\n              <param name=\"admin\" type=\"string\">info@appserver.io</param>\r\n              <param name=\"software\" type=\"string\">\r\n                appserver/1.0.0.0 (darwin) PHP/5.5.16\r\n              </param>\r\n                <param name=\"transport\" type=\"string\">tcp</param>\r\n                <param name=\"address\" type=\"string\">127.0.0.1</param>\r\n                <param name=\"port\" type=\"integer\">9080</param>\r\n                <param name=\"workerNumber\" type=\"integer\">64</param>\r\n                <param name=\"workerAcceptMin\" type=\"integer\">3</param>\r\n                <param name=\"workerAcceptMax\" type=\"integer\">8</param>\r\n                <param name=\"documentRoot\" type=\"string\">webapps</param>\r\n                <param name=\"directoryIndex\" type=\"string\">\r\n                    index.do index.php index.html index.htm\r\n                </param>\r\n                <param name=\"keepAliveMax\" type=\"integer\">64</param>\r\n                <param name=\"keepAliveTimeout\" type=\"integer\">5</param>\r\n                <param name=\"errorsPageTemplatePath\" type=\"string\">\r\n                    var/www/errors/error.phtml\r\n                </param>\r\n            </params>\r\n\r\n            <!-- define the environment variables -->\r\n            <environmentVariables>\r\n              <environmentVariable\r\n                condition=\"\" definition=\"LOGGER_ACCESS=Access\" />\r\n            </environmentVariables>\r\n\r\n            <!-- define the connection handler(s) -->\r\n            <connectionHandlers>\r\n              <connectionHandler\r\n                type=\"\\AppserverIo\\WebServer\\ConnectionHandlers\\HttpConnectionHandler\" />\r\n            </connectionHandlers>\r\n\r\n            <!-- define authentication basic/digest -->\r\n            <authentications>\r\n              <authentication uri=\"^\\/admin.*\">\r\n                <params>\r\n                  <param name=\"type\" type=\"string\">\r\n                    \\AppserverIo\\Http\\Authentication\\BasicAuthentication\r\n                  </param>\r\n                  <param name=\"realm\" type=\"string\">\r\n                    appserver.io Basic Authentication System\r\n                  </param>\r\n                  <param name=\"hash\" type=\"string\">\r\n                    YXBwc2VydmVyOmFwcHNlcnZlci5pMA==\r\n                  </param>\r\n                </params>\r\n              </authentication>\r\n            </authentications>\r\n\r\n            <!-- allow access to everything -->\r\n            <accesses>\r\n              <access type=\"allow\">\r\n                <params>\r\n                  <param name=\"X_REQUEST_URI\" type=\"string\">.*</param>\r\n                </params>\r\n              </access>\r\n            </accesses>\r\n\r\n            <!-- define a virtual host -->\r\n            <virtualHosts>\r\n              <virtualHost name=\"example.local\">\r\n                <params>\r\n                  <param name=\"admin\" type=\"string\">\r\n                    admin@appserver.io\r\n                  </param>\r\n                  <param name=\"documentRoot\" type=\"string\">\r\n                    /opt/appserver/webapps/example\r\n                  </param>\r\n                </params>\r\n              </virtualHost>\r\n            </virtualHosts>\r\n\r\n            <!-- the webserver modules we want to load -->\r\n            <modules>\r\n              <!-- REQUEST_POST hook -->\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\VirtualHostModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\AuthenticationModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\EnvironmentVariableModule\" />\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\RewriteModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\DirectoryModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\AccessModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\CoreModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\PhpModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\FastCgiModule\"/>\r\n              <module\r\n                type=\"\\AppserverIo\\Appserver\\ServletEngine\\ServletEngine\" />\r\n              <!-- RESPONSE_PRE hook -->\r\n              <module\r\n                type=\"\\AppserverIo\\WebServer\\Modules\\DeflateModule\"/>\r\n              <!-- RESPONSE_POST hook -->\r\n              <module\r\n                type=\"\\AppserverIo\\Appserver\\Core\\Modules\\ProfileModule\"/>\r\n            </modules>\r\n\r\n            <!-- bound the file extensions to the responsible module -->\r\n            <fileHandlers>\r\n              <fileHandler name=\"servlet\" extension=\".do\" />\r\n              <fileHandler name=\"fastcgi\" extension=\".php\">\r\n                <params>\r\n                  <param name=\"host\" type=\"string\">127.0.0.1</param>\r\n                  <param name=\"port\" type=\"integer\">9010</param>\r\n                </params>\r\n              </fileHandler>\r\n            </fileHandlers>\r\n\r\n        </server>\r\n\r\n        <!-- Here, additional servers might be added -->\r\n\r\n      </servers>\r\n    </container>\r\n  </containers>\r\n</appserver>\r\n```\r\n\r\nIn the above example you can see three important components of the appserver architecture being\r\nused. The [*container*](docs/docs/architecture.md#container>), [*server*](docs/docs/architecture.md#server) and a\r\n[*protocol*](docs/docs/architecture.md#protocol>) (if you did not read about our basic [architecture](docs/docs/architecture.md)\r\nyou should now). We are basically building up a container which holds a server using the websocket\r\nprotocol to handle incoming requests.\r\n\r\n### Container Configuration\r\n\r\nA *container* is created by using the `container` element within the `containers` collection\r\nof the `appserver` document element. Two parts of the XML create a specific container, in the system on startup:\r\n\r\n* The `type` attribute states a class extending our `AbstractContainerThread`, which defines a\r\n  container to be a specific type of container.\r\n\r\n* The `deployment` element states a class containing preparations for starting up the container.\r\n  It can be considered a hook, which will be invoked before the container will be available.\r\n\r\nThat is basically everything there is to do to create a new container. To make use of it, it has\r\nto contain at least one *server* within its `servers` collection.\r\n\r\n### Server Configuration\r\n\r\nThe *servers* contained by our *container* can also be loosely drafted by the XML configuration and\r\nwill be instantiated on container boot-up. To enable a *server* you have to mention three basic\r\nattributes of the element:\r\n\r\n* The `type` specifies a class implementing the `ServerInterface`, which implements the basic\r\n  behaviour of the server on receiving a connection and how it will handle it.\r\n\r\n* The `socket` attribute specifies the type of socket the server should open. E.g. a stream or\r\n  asynchronous socket\r\n\r\n* The `serverContext` specifies the server's source of configuration and container for runtime\r\n  information e.g. ServerVariables like `DOCUMENT_ROOT`\r\n\r\nSo we have our specific server which will open a certain port and operate in a defined context. But\r\nto make the server handle a certain type of request, it needs to know which *protocol* to speak.\r\n\r\nThis can be done using the `connectionHandler` element. Certain server wrappers can handle certain\r\nprotocols. Therefore, we can use the protocols which a server wrapper, e.g. `WebServer` supports in\r\nform of connection handlers. [WebServer](<https://github.com/appserver.io/webserver>)\r\noffers a `HttpConnectionHandler` class. By using it, the server is able to understand the HTTP\r\nprotocol.\r\n\r\n### Application Configuration\r\n\r\nBeside the Container and Server configuration, it is also possible to configure an application. Each application\r\ncan have it's own autoloaders and managers. By default, each application found in the application\r\nservers webapp directory `/opt/appserver/webapps` will be initialized with the defaults, defined\r\nin `/opt/appserver/etc/appserver/conf.d/context.xml`\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<context\r\n  name=\"globalBaseContext\"\r\n  factory=\"AppserverIo\\Appserver\\Application\\ApplicationFactory\"\r\n  type=\"AppserverIo\\Appserver\\Application\\Application\"\r\n  xmlns=\"http://www.appserver.io/appserver\">\r\n\r\n  <!--\r\n  <params>\r\n    <param name=\"cache.dir\" type=\"string\">/cache</param>\r\n    <param name=\"session.dir\" type=\"string\">/session</param>\r\n  </params>\r\n  -->\r\n\r\n  <classLoaders>\r\n\r\n    <!-- necessary to load files from the vendor directory of your application -->\r\n    <classLoader\r\n      name=\"ComposerClassLoader\"\r\n      interface=\"ClassLoaderInterface\"\r\n      type=\"AppserverIo\\Appserver\\Core\\ComposerClassLoader\"\r\n      factory=\"AppserverIo\\Appserver\\Core\\ComposerClassLoaderFactory\">\r\n      <directories>\r\n        <directory>/vendor</directory>\r\n      </directories>\r\n    </classLoader>\r\n\r\n    <!-- necessary to load files from WEB-INF/classes and META-INF/classes, also -->\r\n    <!-- provides the functionality for Design-by-Contract and AOP               -->\r\n    <classLoader\r\n      name=\"DgClassLoader\"\r\n      interface=\"ClassLoaderInterface\"\r\n      type=\"AppserverIo\\Appserver\\Core\\DgClassLoader\"\r\n      factory=\"AppserverIo\\Appserver\\Core\\DgClassLoaderFactory\">\r\n      <params>\r\n        <param name=\"environment\" type=\"string\">production</param>\r\n        <param name=\"enforcementLevel\" type=\"integer\">7</param>\r\n        <param name=\"typeSafety\" type=\"boolean\">1</param>\r\n        <param name=\"processing\" type=\"string\">logging</param>\r\n      </params>\r\n      <directories>\r\n        <directory enforced=\"true\">/common/classes</directory>\r\n        <directory enforced=\"true\">/WEB-INF/classes</directory>\r\n        <directory enforced=\"true\">/META-INF/classes</directory>\r\n      </directories>\r\n    </classLoader>\r\n  </classLoaders>\r\n\r\n  <managers>\r\n\r\n    <!-- provides object management services -->\r\n    <manager\r\n      name=\"ObjectManagerInterface\"\r\n      type=\"AppserverIo\\Appserver\\DependencyInjectionContainer\\ObjectManager\"\r\n      factory=\"AppserverIo\\Appserver\\DependencyInjectionContainer\\ObjectManagerFactory\">\r\n      <descriptors>\r\n        <descriptor>AppserverIo\\Appserver\\DependencyInjectionContainer\\Description\\ServletDescriptor</descriptor>\r\n        <descriptor>AppserverIo\\Appserver\\DependencyInjectionContainer\\Description\\SingletonSessionBeanDescriptor</descriptor>\r\n        <descriptor>AppserverIo\\Appserver\\DependencyInjectionContainer\\Description\\StatefulSessionBeanDescriptor</descriptor>\r\n        <descriptor>AppserverIo\\Appserver\\DependencyInjectionContainer\\Description\\StatelessSessionBeanDescriptor</descriptor>\r\n        <descriptor>AppserverIo\\Appserver\\DependencyInjectionContainer\\Description\\MessageDrivenBeanDescriptor</descriptor>\r\n      </descriptors>\r\n    </manager>\r\n\r\n    <!-- provides services necessary for DI -->\r\n    <manager\r\n      name=\"ProviderInterface\"\r\n      type=\"AppserverIo\\Appserver\\DependencyInjectionContainer\\Provider\"\r\n      factory=\"AppserverIo\\Appserver\\DependencyInjectionContainer\\ProviderFactory\"/>\r\n\r\n    <!-- provides the services necessary to handle Session- and MessageBeans -->\r\n    <manager\r\n      name=\"BeanContextInterface\"\r\n      type=\"AppserverIo\\Appserver\\PersistenceContainer\\BeanManager\"\r\n      factory=\"AppserverIo\\Appserver\\PersistenceContainer\\BeanManagerFactory\">\r\n        <!-- params>\r\n          <param name=\"lifetime\" type=\"integer\">1440</param>\r\n          <param name=\"garbageCollectionProbability\" type=\"float\">0.1</param>\r\n        </params -->\r\n        <directories>\r\n          <directory>/META-INF/classes</directory>\r\n        </directories>\r\n      </manager>\r\n\r\n      <!-- provides the functionality to define and run a Queue -->\r\n      <manager\r\n        name=\"QueueContextInterface\"\r\n        type=\"AppserverIo\\Appserver\\MessageQueue\\QueueManager\"\r\n        factory=\"AppserverIo\\Appserver\\MessageQueue\\QueueManagerFactory\"/>\r\n\r\n      <!-- provides the functionality to define Servlets handling HTTP request -->\r\n      <manager\r\n        name=\"ServletContextInterface\"\r\n        type=\"AppserverIo\\Appserver\\ServletEngine\\ServletManager\"\r\n        factory=\"AppserverIo\\Appserver\\ServletEngine\\ServletManagerFactory\">\r\n        <directories>\r\n          <directory>/WEB-INF/classes</directory>\r\n        </directories>\r\n      </manager>\r\n\r\n      <!-- provides functionality to handle HTTP sessions -->\r\n      <manager\r\n        name=\"SessionManagerInterface\"\r\n        type=\"AppserverIo\\Appserver\\ServletEngine\\StandardSessionManager\"\r\n        factory=\"AppserverIo\\Appserver\\ServletEngine\\StandardSessionManagerFactory\"/>\r\n\r\n      <!-- provides functionality to handle Timers -->\r\n      <manager\r\n        name=\"TimerServiceContextInterface\"\r\n        type=\"AppserverIo\\Appserver\\PersistenceContainer\\TimerServiceRegistry\"\r\n        factory=\"AppserverIo\\Appserver\\PersistenceContainer\\TimerServiceRegistryFactory\"/>\r\n\r\n      <!-- provides functionality to handle HTTP basic/digest authentication -->\r\n      <manager\r\n        name=\"AuthenticationManagerInterface\"\r\n        type=\"AppserverIo\\Appserver\\ServletEngine\\Authentication\\StandardAuthenticationManager\"\r\n        factory=\"AppserverIo\\Appserver\\ServletEngine\\Authentication\\StandardAuthenticationManagerFactory\"/>\r\n\r\n      <!-- provides functionality to preload Advices found in WEB-INF/classes or META-INF/classes -->\r\n      <manager\r\n        name=\"AspectManagerInterface\"\r\n        type=\"AppserverIo\\Appserver\\AspectContainer\\AspectManager\"\r\n        factory=\"AppserverIo\\Appserver\\AspectContainer\\AspectManagerFactory\"/>\r\n  </managers>\r\n</context>\r\n```\r\n\r\nIf your application doesn't use any of the defined class loaders or managers or you want to implement\r\nyour own managers, you can define them in a `context.xml` file, which you must include with your\r\napplication. Your own customized file, has to be stored in `META-INF/context.xml`. When the application\r\nserver starts, this file will be parsed and your application will be initialized with the class loaders\r\nand managers you have defined there.\r\n\r\n> Please be aware: the default class loaders and managers provide most of the functionality\r\n> described above. So if you remove them from the `context.xml`, you have to expect unexpected and incorrect behaviour.\r\n\r\n### Module Configuration\r\n\r\nThe web server comes with a package of default modules. The functionality that allows us to configure\r\na virtual host or environment variables, for example, is also provided by two very important modules.\r\n\r\n#### Rewrite Module\r\n\r\nThe rewrite module can be used according to the `\\AppserverIo\\WebServer\\Interfaces\\HttpModuleInterface` interface.\r\nIt needs an initial call of the `init` method and will process any request offered to the `process` method.\r\nThe module is best used within the [`webserver`](<https://github.com/appserver-io/webserver>)\r\nproject, as it offers all the needed infrastructure.\r\n\r\n##### Rules\r\n\r\nMost important part of the rewrite module is the way in which it can perform rewrites. All rewrites are\r\nbased on rewrite rules which consist of three important parts:\r\n\r\n- *condition string* : Conditions, which have to be met in order for the rule to take effect.\r\n  This is explained in more detail [under condition syntax](#condition-syntax)\r\n\r\n- *target string* : The target to rewrite the requested URI to. Within this string you can use\r\n  backreferences similar\r\n  to the Apache mod_rewrite module with the difference that you have to use the `$ syntax`\r\n  (instead of the `$/%/%{} syntax` of Apache).\r\n\r\n  Matching rule conditions, which you specifically pick out via regex are also part of available back-references\r\n  as well as server and environment variables.\r\n\r\n  *Simple example* : A condition like `(.+)@$X_REQUEST_URI` would produce a back reference `$1`\r\n  with the value `/index` for a requested URI `/index`. The target string `$1/welcome.html` would\r\n  therefore result in a rewrite to `/index/welcome.html`\r\n\r\n- *flag string* : You can use flags similar to mod_rewrite which are used to make rules react in a\r\n  certain way or influence further processing. Learn more in the section [on flage](#flags)\r\n\r\n##### Condition Syntax\r\n\r\nThe Syntax of possible conditions is roughly based on the possibilities of Apache's RewriteCondition\r\nand RewriteRule combined.\r\n\r\nTo make use of such a combination you can chain conditions together using the `{OR}` symbol for\r\nOR-combined, and the `{AND}` symbol for AND-combined conditions.\r\n\r\nPlease be aware that AND takes precedence over OR! Conditions can either be PCRE regex or certain fixed\r\nexpressions. So a condition string of `([A-Z]+\\.txt){OR}^/([0-9]+){AND}-f` would match only real files\r\n(through `-f`) which either begin with numbers or end with capital letters and the extension .txt.\r\n\r\nAs you might have noticed: Backslashes do **not have to be escaped**.\r\n\r\nYou might also be curious of the `-f` condition. This is a direct copy of Apaches -f RewriteCondition.\r\nWe also support several other expressions to regex based conditions which are:\r\n\r\n - *<<COMPARE_STRING>* : Is the operand lexically preceding `<COMPARE_STRING>`?\r\n - *><COMPARE_STRING>* : Is the operand lexically following `<COMPARE_STRING>`?\r\n - *=<COMPARE_STRING>* : Is the operand lexically equal to `<COMPARE_STRING>`?\r\n - *-d* : Is the operand a directory?\r\n - *-f* : Is the operand a real file?\r\n - *-s* : Is the operand a real file of a size greater than 0?\r\n - *-l* : Is the operand a symbolic link?\r\n - *-x* : Is the operand an executable file?\r\n\r\nIf you are wondering what the `operand` might be: it is **whatever you want it to be**! You can specify\r\nany operand you like using the `@` symbol. All conditions within a rule will use the next operand to\r\ntheir right and if none is given the requested URI. For example:\r\n\r\n- *`([A-Z]+\\.txt){OR}^/([0-9]+)`* Will take the requested URI for both conditions (note the `{OR}` symbol)\r\n- *`([A-Z]+\\.txt){OR}^/([0-9]+)@$DOCUMENT_ROOT`* Will test both conditions against the document root\r\n- *`([A-Z]+\\.txt)@$DOCUMENT_ROOT{OR}^/([0-9]+)`* Will only test the first one against the document root\r\n  and the second against the requested URI\r\n\r\nYou might have noted the `$` symbol before `DOCUMENT_ROOT` and remembered it from the back-reference\r\nsyntax. That's because all Apache common server vars can be explicitly used as back-references too!\r\n\r\nThat does not work for you? Need the exact opposite? No problem!\r\n\r\nAll conditions, whether regex or expression based can be negated using the `!` symbol in front of\r\nthem! So `!^([0-9]+)` would match all strings which do NOT begin with a number and `!-d` would match\r\nall non-directories.\r\n\r\n##### Flags\r\n\r\nFlags are used to further influence processing. You can specify as many flags per rewrite as you like,\r\nbut be aware of their impact! Syntax for several flags is simple: just separate them with a `,` symbol.\r\nFlags which might accept a parameter can be assigned one by using the `=` symbol. Currently supported\r\nflags are:\r\n\r\n- *L* : As rules are normally processed one after the other, the `L` flag will make the flagged rule\r\n  the last one processed if matched.\r\n\r\n- *R* : If this flag is set we will redirect the client to the URL specified in the `target string`.\r\n   If this is just a URI, we will redirect to the same host. You might also specify a custom status\r\n   code between 300 and 399 to indicate the reason for/kind of the redirect. Default is `301` aka\r\n   `permanent`\r\n\r\n- *M* : Stands for map. Using this flag you can specify an external source (have a look at the Injector\r\n  classes of the WebServer project) of a target map. With `M=<MY_BACKREFERENCE>` you can specify what\r\n  the map's index has to be to match. This matching is done **only** if the rewrite condition matches and will\r\n  behave as another condition\r\n\r\n#### Virtual-Host Module\r\n\r\nThe module can be used according to the `\\AppserverIo\\WebServer\\Interfaces\\HttpModuleInterface`\r\ninterface. It needs an initial call of the `init` method and will process any request offered to\r\nthe `process` method. The module is best used within the [webserver](<https://github.com/appserver-io/webserver>)\r\nproject as it offers all needed infrastructure.\r\n\r\nIf you need to configure a virtual host, it should look like the\r\nfollowing example, which enables a Magento installation under `http://magento.dev:9080`.\r\n\r\n```xml\r\n<virtualHosts>\r\n  <virtualHost name=\"magento.dev\">\r\n    <params>\r\n        <param name=\"admin\" type=\"string\">info@appserver.io</param>\r\n        <param name=\"documentRoot\" type=\"string\">webapps/magento</param>\r\n    </params>\r\n    <rewrites>\r\n        <rewrite condition=\"-d{OR}-f{OR}-l\" target=\"\" flag=\"L\" />\r\n        <rewrite condition=\"(.*)\" target=\"index.php/$1\" flag=\"L\" />\r\n    </rewrites>\r\n    <accesses>\r\n        <access type=\"allow\">\r\n            <params>\r\n                <param name=\"X_REQUEST_URI\" type=\"string\">\r\n                  ^\\/([^\\/]+\\/)?(media|skin|js|index\\.php).*\r\n                </param>\r\n            </params>\r\n        </access>\r\n    </accesses>\r\n  </virtualHost>\r\n</virtualHosts>\r\n```\r\n\r\n## Configuration Defaults\r\n\r\nYou will see that we provide basic front-end implementations of services the appserver runtime\r\nprovides. If you want to use these services yourself, you should have a look into the code of our\r\napps and read about [app development](#deployment).\r\n\r\nYou might be curious about the different ports we use. Per default, the appserver will open several\r\nports at which it's services are available. As we do not want to block (or be blocked by) other\r\nservices, we use ports in a higher range.\r\n\r\nAs a default, we use the following ports:\r\n\r\n* WebContainer\r\n\r\n    - HTTP Server: `9080`\r\n    - HTTPS Server: `9443`\r\n\r\n* Persistence-MQ-Container\r\n\r\n    - Persistence-Container: `8585`\r\n    - Message-Queue: `8587`\r\n\r\nYou can change the default port mapping by using the [configuration file](#the-architecture).\r\nIf you are interested in our naming, you can see our container->server pattern, you might want to\r\nhave a deeper look into our [architecture](docs/docs/architecture.md)\r\n\r\n# Deployment\r\n\r\nThe deploy directory in the appserver.io Application Server distribution is the location end users can place their\r\ndeployment content (e. g. phar files) to have it deployed into the server runtime.\r\n\r\nUsers, particularly those running production systems, are encouraged to use the appserver.io AS management APIs to\r\nupload and deploy deployment content.\r\n\r\n## Deployment Modes\r\n\r\nThe scanner actually only supports a manual deployment mode, which means that you have to restart the server to process\r\ndeployment of your content. In this mode, the scanner will not attempt to directly monitor the deployment content and\r\ndecide if or when the end user wishes the content to be deployed or undeployed. Instead, the scanner relies on a system\r\nof marker files, with the user's addition or removal of a marker file serving as a sort of command telling the scanner\r\nto deploy, undeploy or redeploy content.\r\n\r\nIt is also possible to copy your unzipped content directly into the webapps folder. After restarting the webserver\r\nyour content will then be deployed without having any impact on the deployment scanner, because only zipped (.phar)\r\ncontent will be recognized.\r\n\r\n## Marker Files\r\n\r\nThe marker files always have the same name as the deployment content to which they relate, but with an additional file\r\nsuffix appended. For example, the marker file to indicate the example.phar file should be deployed is named\r\nexample.phar.dodeploy. Different marker file suffixes have different meanings.\r\n\r\nThe relevant marker file types are:\r\n\r\n| Marker       | Description                                                     |\r\n|:-------------|:----------------------------------------------------------------|\r\n| .dodeploy    | Placed by the user to indicate that the given content should be deployed or redeployed into the runtime.                     |\r\n| .deploying   | Placed by the deployment scanner service to indicate that it has noticed a .dodeploy file and is in the process of deploying the content. This marker file will be deleted, when the deployment process completes.                                   |\r\n| .deployed    | Placed by the deployment scanner service to indicate that the given content has been deployed into the runtime. If an end user deletes this file and no other marker is available, the content will be undeployed.                                     |\r\n| .failed      | Placed by the deployment scanner service to indicate that the given content failed to deploy into the runtime. The content of the file will include some information about the cause of the failure. Note that, removing this file will make the deployment eligible for deployment again.                       |\r\n| .undeploying | Placed by the deployment scanner service to indicate that it has noticed a .deployed file has been deleted and the content is being undeployed. This marker file will be deleted, when the undeployment process completes.                        |\r\n| .undeployed  | Placed by the deployment scanner service to indicate that the given content has been undeployed from the runtime. If this marker file is deleted by the user, it has no impact.                       |\r\n\r\n## Basic workflows\r\n\r\nAll examples assume variable $AS points to the root of the appserver.io AS distribution.\r\n\r\nWindows users: the examples below use UNIX shell commands; see the [Windows Notes](#windows-notes) below.\r\n\r\n1. Add new zipped (.phar) content and deploy it:\r\n\r\n```\r\n$ cp target/example.phar $AS/deploy\r\n$ touch $AS/deploy/example.phar.dodeploy\r\n```\r\n\r\n2. Undeploy currently deployed zipped (.phar) content:\r\n\r\n```\r\n$ rm $AS/deploy/example.phar.deployed\r\n```\r\n\r\n3. Replace currently deployed zipped (.phar) content with a new version and redeploy it:\r\n\r\n```\r\n$ cp target/example.phar $AS/deploy\r\n$ mv $AS/deploy/example.phar.deployed $AS/deploy/example.phar.dodeploy\r\n```\r\n\r\n## Windows Notes\r\n\r\nThe above examples use UNIX shell commands. Windows equivalents are:\r\n\r\n| UNIX           | Windows                 |\r\n|:---------------|:------------------------|\r\n| cp src dest    | xcopy /y src dest       |\r\n| cp -r src dest | xcopy /e /s /y src dest |\r\n| rm afile       | del afile               |\r\n| touch afile    | echo >> afile           |\r\n\r\nNote that the behavior of ```touch``` and ```echo``` are different, but the differences are not relevant to the usages.\r\n\r\n# Uninstall\r\n\r\nBefore uninstalling, you should [stop all the services](#start-and-stop-scripts), which are still running (rpm-based packages will see to that themselves), otherwise there might be problems with existing pid-files on Linux and Mac for the next time you install it.\r\n\r\nTo uninstall the appserver on Linux, you might rely on your package management system.\r\nOn Windows you can use the normal uninstall process provided by the operating system.\r\n\r\nUnder Mac OS X you can simply delete the `/opt/appserver` folder that containers all installed files.\r\n\r\n# External Links\r\n\r\n* All about appserver.io at [appserver.io](http://www.appserver.io)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}